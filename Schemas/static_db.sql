--
-- Script was generated by Devart dbForge Studio for MySQL, Version 10.0.150.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 27/6/2024 19:33:01
-- Server version: 8.3.0
--

--
-- Disable foreign keys
--
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

--
-- Set SQL mode
--
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

--
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8mb4';

DROP DATABASE IF EXISTS static_db;

CREATE DATABASE IF NOT EXISTS static_db
CHARACTER SET utf8mb4
COLLATE utf8mb4_0900_ai_ci;

--
-- Set default database
--
USE static_db;

--
-- Create table `material`
--
CREATE TABLE IF NOT EXISTS material (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  name varchar(15) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  description varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'Sin descripción',
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = 'Material of Hoop',
ROW_FORMAT = DYNAMIC;

DELIMITER $$

--
-- Create function `existMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existMaterial (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM material m
  WHERE m.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `updateMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS updateMaterial (IN id int UNSIGNED, IN nameIN varchar(20), IN descriptionIN varchar(80))
DETERMINISTIC
BEGIN

  DECLARE result text;

  IF (existMaterial(id) = TRUE) THEN
    UPDATE LOW_PRIORITY material m
    SET m.id = id,
        m.name = nameIN,
        m.description = descriptionIN
    WHERE m.id = id;

    SELECT
      'Successful Updated!' INTO result;
  ELSE
    SELECT
      'Unsucessful Updated!' INTO result;
  END IF;

  SELECT
    result AS `response`;

END
$$

--
-- Create procedure `deleteMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteMaterial (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existMaterial(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM material m
    WHERE m.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `insertMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertMaterial (IN nameIN varchar(20), IN descriptionIN varchar(60))
DETERMINISTIC
BEGIN

  DECLARE selected bigint;
  DECLARE result json;

  SELECT
    COUNT(*) INTO selected
  FROM material m
  WHERE m.name LIKE nameIN;

  IF (selected = 0) THEN
    INSERT INTO material (name, description)
      VALUES (nameIN, descriptionIN);

    SELECT
      m.id AS `key`,
      m.name AS `material`,
      m.description AS `description`,
      '[]' AS `specifications`
    FROM material m
    WHERE m.name = nameIN;

  ELSE
    SELECT
      'Already Exists!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `specification`
--
CREATE TABLE IF NOT EXISTS specification (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  material int UNSIGNED NOT NULL,
  name varchar(15) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  description varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'Sin Descripción',
  createdAt datetime NOT NULL,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = 'Specification of a Material',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE specification
ADD CONSTRAINT FK_specification_material_id FOREIGN KEY (material)
REFERENCES material (id) ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `existSpecimen`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existSpecimen (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM specification s
  WHERE s.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create function `existSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existSpecification (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected int;
  SELECT
    COUNT(*) INTO selected
  FROM specification s
  WHERE s.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `updateSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS updateSpecification (IN id int UNSIGNED, IN nameIN varchar(20), IN descriptionIN varchar(80))
DETERMINISTIC
BEGIN

  DECLARE result text;

  IF (existSpecification(id) = TRUE) THEN
    UPDATE LOW_PRIORITY specification s
    SET s.id = id,
        s.name = nameIN,
        s.description = descriptionIN
    WHERE s.id = id;

    SELECT
      'Successful Updated!' INTO result;
  ELSE
    SELECT
      'Unsuccessful Updated!' INTO result;
  END IF;

  SELECT
    result AS `response`;
END
$$

--
-- Create procedure `deleteSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteSpecification (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existSpecification(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM specification s
    WHERE s.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create function `existConfiguration`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existConfiguration (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM specification s
  WHERE s.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `selectSpecifications`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE IF NOT EXISTS selectSpecifications (IN idMaterial int UNSIGNED)
DETERMINISTIC
BEGIN

  SELECT
    s.id AS idSpecification,
    s.name AS nameSpecification,
    s.description AS descriptionSpecification
  FROM specification s
  WHERE s.material = idMaterial;

END
$$

--
-- Create procedure `insertSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertSpecification (IN materialIN int UNSIGNED, IN nameIN varchar(20), IN descriptionIN varchar(60))
DETERMINISTIC
BEGIN

  DECLARE selected bigint;

  SELECT
    COUNT(*) INTO selected
  FROM specification s
  WHERE s.name = nameIN
  AND s.material = materialIN;

  IF (selected = 0) THEN
    INSERT INTO specification (material, name, description)
      VALUES (materialIN, nameIN, descriptionIN);

    SELECT
      s.id AS `key`,
      s.name AS `specification`,
      s.description AS `description`,
      '[]' AS `configurations`
    FROM specification s
    WHERE s.name LIKE nameIN;

  ELSE
    SELECT
      'Already Exists!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `settings_specification`
--
CREATE TABLE IF NOT EXISTS settings_specification (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  specification int UNSIGNED NOT NULL,
  time smallint UNSIGNED NOT NULL,
  timeType varchar(1) NOT NULL DEFAULT 'h',
  temperature tinyint UNSIGNED NOT NULL,
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = 'Settings by Specification',
ROW_FORMAT = DYNAMIC;

--
-- Create index `FK_period_by_material_material_id` on table `settings_specification`
--
ALTER TABLE settings_specification
ADD INDEX FK_period_by_material_material_id (specification);

--
-- Create foreign key
--
ALTER TABLE settings_specification
ADD CONSTRAINT FK_specification_configuration_specification_id FOREIGN KEY (specification)
REFERENCES specification (id) ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `selectSettingsSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectSettingsSpecification (idSpecification int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint;

  SELECT
    COUNT(*) INTO elements
  FROM settings_specification sc
  WHERE sc.specification = idSpecification;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', sc.id,
      'time', sc.time,
      'type', sc.timeType,
      'temperature', sc.temperature)) INTO result
    FROM settings_specification sc
    WHERE sc.specification = idSpecification;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create function `selectSpecifications`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectSpecifications (idMaterial int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint;

  SELECT
    COUNT(*) INTO elements
  FROM specification s
  WHERE s.material = idMaterial;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', s.id,
      'specification', s.name,
      'description', (IF(s.description IS NULL, '', s.description)),
      'configurations', (selectSettingsSpecification(s.id)))) INTO result
    FROM specification s
    WHERE s.material = idMaterial;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create procedure `selectMaterialsJSON`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectMaterialsJSON ()
DETERMINISTIC
BEGIN

  SELECT
    JSON_ARRAYAGG(JSON_OBJECT('key', m.id,
    'material', m.name,
    'description', (IF(m.description IS NULL, 'Sin Descripción', m.description)),
    'specifications', (selectSpecifications(m.id)))) AS `materials`
  FROM material m;

END
$$

--
-- Create function `existSettingsSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existSettingsSpecification (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);

  SELECT
    COUNT(*) INTO selected
  FROM settings_specification sc
  WHERE sc.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `updateSettingsSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS updateSettingsSpecification (IN id int UNSIGNED, IN timeIN smallint, IN timeTypeIN varchar(1), IN temperatureIN tinyint)
DETERMINISTIC
BEGIN

  DECLARE result text;

  IF (existSettingsSpecification(id) = TRUE) THEN
    UPDATE LOW_PRIORITY settings_specification sc
    SET sc.id = id,
        sc.time = timeIN,
        sc.timeType = timeTypeIN,
        sc.temperature = temperatureIN
    WHERE sc.id = id;

    SELECT
      'Successful Updated!' INTO result;
  ELSE
    SELECT
      'Unsuccessful Updated!' INTO result;
  END IF;

  SELECT
    result AS response;
END
$$

--
-- Create procedure `deleteSettingsSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteSettingsSpecification (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existSettingsSpecification(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM settings_specification sc
    WHERE sc.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectSettingsSpecification`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE IF NOT EXISTS selectSettingsSpecification (IN idSpecification int UNSIGNED)
DETERMINISTIC
BEGIN

  SELECT
    sc.id AS idSetting,
    sc.time AS time,
    sc.timeType AS timeType,
    sc.temperature AS temperature
  FROM settings_specification sc
  WHERE sc.specification = idSpecification;

END
$$

--
-- Create procedure `insertSettingsSpecification`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertSettingsSpecification (IN specificationIN int UNSIGNED, IN timeIN smallint, IN timeTypeIN varchar(1), IN temperatureIN tinyint)
DETERMINISTIC
BEGIN

  DECLARE selected bigint;

  SELECT
    COUNT(*) INTO selected
  FROM settings_specification sc
  WHERE sc.specification = specificationIN
  AND sc.time = timeIN
  AND sc.temperature = temperatureIN;

  IF (selected = 0) THEN
    INSERT INTO settings_specification (specification, time, timeType, temperature)
      VALUES (specificationIN, timeIN, timeTypeIN, temperatureIN);

    SELECT
      sc.id AS `key`,
      sc.time AS `time`,
      sc.timeType AS `timeType`,
      sc.temperature AS `temperature`
    FROM settings_specification sc
    WHERE sc.specification = specificationIN
    AND sc.time = timeIN
    AND sc.temperature = temperatureIN;

  ELSE
    SELECT
      'Already Exists!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `standard`
--
CREATE TABLE IF NOT EXISTS standard (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  name varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 16384,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_general_ci,
COMMENT = 'Standards: ISO, IRAM, ...',
ROW_FORMAT = DYNAMIC;

DELIMITER $$

--
-- Create function `existStandard`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existStandard (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM standard s
  WHERE s.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `updateStandard`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS updateStandard (IN id int UNSIGNED, IN nameIN varchar(60))
DETERMINISTIC
BEGIN

  DECLARE result text;

  IF (existStandard(id) = TRUE) THEN
    UPDATE LOW_PRIORITY standard s
    SET s.id = id,
        s.name = nameIN
    WHERE s.id = id;

    SELECT
      'Successful Updated!' INTO result;
  ELSE
    SELECT
      'Unsucessful Updated!' INTO result;
  END IF;

  SELECT
    result AS `response`;

END
$$

--
-- Create procedure `deleteStandard`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteStandard (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existStandard(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM standard s
    WHERE s.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectStandards`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE IF NOT EXISTS selectStandards ()
DETERMINISTIC
BEGIN

  SELECT
    s.id AS idStandard,
    s.name AS standardName
  FROM standard s;

END
$$

--
-- Create procedure `insertStandard`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertStandard (IN nameIn varchar(40))
DETERMINISTIC
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM standard s
  WHERE s.name = nameIn;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO standard (name)
      VALUES (nameIn);

    SELECT
      s.id AS `key`,
      s.name AS `standard`,
      '[]' AS `materials`,
      '[]' AS `enviroments`,
      '[]' AS `endCaps`,
      '[]' AS conditionalPeriods
    FROM standard s
    WHERE s.name LIKE nameIn;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `test_type`
--
CREATE TABLE IF NOT EXISTS test_type (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  standard int UNSIGNED NOT NULL,
  testType varchar(150) NOT NULL,
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = 'Test Type by Standard',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE test_type
ADD CONSTRAINT FK_test_type_standard_id FOREIGN KEY (standard)
REFERENCES standard (id) ON DELETE CASCADE ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `selectTest_Type`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectTest_Type (idStandard int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint;

  SELECT
    COUNT(*) INTO elements
  FROM test_type tt
  WHERE tt.standard = idStandard;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', tt.id,
      'testtype', tt.testType)) INTO result
    FROM test_type tt
    WHERE tt.standard = idStandard;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create function `existTest_Type`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existTest_Type (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM test_type tt
  WHERE tt.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `deleteTestType`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteTestType (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existTest_Type(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM test_type tt
    WHERE tt.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectTestType`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectTestType (IN idStandard int UNSIGNED)
DETERMINISTIC
BEGIN

  SELECT
    tt.id,
    tt.testType
  FROM test_type tt
  WHERE tt.standard = idStandard;

END
$$

--
-- Create procedure `insertTestType`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertTestType (IN idStandard int UNSIGNED, IN testTypeIN varbinary(255))
DETERMINISTIC
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM test_type tt
  WHERE tt.standard = idStandard
  AND tt.testType = testTypeIN;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO test_type (standard, testType)
      VALUES (idStandard, testTypeIN);

    SELECT
      tt.id AS `key`,
      tt.testType AS `testtype`
    FROM test_type tt
    WHERE tt.standard = idStandard
    AND tt.testType = testTypeIN;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `material_has_standard`
--
CREATE TABLE IF NOT EXISTS material_has_standard (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  material int UNSIGNED NOT NULL,
  standard int UNSIGNED NOT NULL,
  type varchar(25) NOT NULL DEFAULT 'Plastico',
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 8192,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = 'Related Materials to a Standard',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE material_has_standard
ADD CONSTRAINT FK_material_has_standard_material_id FOREIGN KEY (material)
REFERENCES material (id) ON DELETE CASCADE ON UPDATE CASCADE;

--
-- Create foreign key
--
ALTER TABLE material_has_standard
ADD CONSTRAINT FK_material_has_standard_standard_id FOREIGN KEY (standard)
REFERENCES standard (id) ON DELETE CASCADE ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `selectMaterials_has_Standard`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectMaterials_has_Standard (idStandard int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint;

  SELECT
    COUNT(*) INTO elements
  FROM material_has_standard mhs
  WHERE mhs.standard = idStandard;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', mhs.id,
      'idMaterial', mhs.material,
      'material', m.name,
      'descriptioin', m.description)) INTO result
    FROM material_has_standard mhs
      INNER JOIN material m
        ON m.id = mhs.material
    WHERE mhs.standard = idStandard;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create function `existRelatedMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existRelatedMaterial (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM material_has_standard mhs
  WHERE mhs.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `deleteRelatedMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteRelatedMaterial (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existRelatedMaterial(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM material_has_standard mhs
    WHERE mhs.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectMaterials`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE IF NOT EXISTS selectMaterials (IN idStandard int UNSIGNED)
DETERMINISTIC
BEGIN

  SELECT
    mhs.material AS idMaterial,
    m.name AS materialName,
    m.description AS materialDescription,
    mhs.type AS materialType
  FROM material m
    INNER JOIN material_has_standard mhs
      ON m.id = mhs.material
  WHERE mhs.standard = standard;

END
$$

--
-- Create procedure `insertRelatedMaterial`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertRelatedMaterial (IN idStandard int UNSIGNED, IN idMaterial int UNSIGNED)
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM material_has_standard mhs
  WHERE mhs.material = idMaterial
  AND mhs.standard = idStandard;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO material_has_standard (material, standard)
      VALUES (idMaterial, idStandard);

    SELECT
      mhs.id AS `key`,
      m.id AS `idMaterial`,
      m.name AS `material`
    FROM material_has_standard mhs
      INNER JOIN material m
        ON mhs.material = m.id
    WHERE mhs.material = idMaterial
    AND mhs.standard = idStandard;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `enviroment`
--
CREATE TABLE IF NOT EXISTS enviroment (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  standard int UNSIGNED NOT NULL,
  inside varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  outside varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT 'No Fluid',
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 4096,
CHARACTER SET latin1,
COLLATE latin1_swedish_ci,
COMMENT = 'Enviroments related to a Standard',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE enviroment
ADD CONSTRAINT FK_enviroment_standard_id FOREIGN KEY (standard)
REFERENCES standard (id) ON DELETE CASCADE ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `selectEnviroments_has_Standard`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectEnviroments_has_Standard (idStandard int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint;

  SELECT
    COUNT(*) INTO elements
  FROM enviroment e
  WHERE e.standard = idStandard;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', e.id,
      'insideFluid', e.inside,
      'outsideFluid', e.outside)) INTO result
    FROM enviroment e
    WHERE e.standard = idStandard;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create function `existEnviroment`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existEnviroment (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM enviroment e
  WHERE e.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `deleteEnviroment`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteEnviroment (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existEnviroment(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM enviroment e
    WHERE e.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectEnviroment`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectEnviroment (IN idStandard int UNSIGNED)
DETERMINISTIC
BEGIN

  SELECT
    ehs.id,
    ehs.inside#,
  #ehs.outside
  FROM enviroment ehs
  WHERE ehs.standard = idStandard;

END
$$

--
-- Create procedure `insertEnviroment`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertEnviroment (IN idStandard int UNSIGNED, IN insideFluid varchar(30))
DETERMINISTIC
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM enviroment e
  WHERE e.standard = idStandard
  AND e.inside LIKE insideFluid;
  #AND e.outside LIKE outsideFluid;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO enviroment (standard, inside)
      VALUES (idStandard, insideFluid);

    SELECT
      e.id AS `key`,
      e.inside AS `insideFluid`
    #      e.outside AS `outsideFluid`
    FROM enviroment e
    WHERE e.standard = idStandard
    AND e.inside LIKE insideFluid;
  #    AND e.outside LIKE outsideFluid;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `endcap`
--
CREATE TABLE IF NOT EXISTS endcap (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  standard int UNSIGNED NOT NULL,
  name varchar(15) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 5461,
CHARACTER SET latin1,
COLLATE latin1_swedish_ci,
COMMENT = 'End Cap related to a Standard',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE endcap
ADD CONSTRAINT FK_endcap_standard_id FOREIGN KEY (standard)
REFERENCES standard (id) ON DELETE CASCADE ON UPDATE CASCADE;

DELIMITER $$

--
-- Create function `selectEndCaps_has_Standard`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectEndCaps_has_Standard (idStandard int UNSIGNED)
RETURNS json
DETERMINISTIC
BEGIN

  DECLARE result json;
  DECLARE elements tinyint(1);

  SELECT
    COUNT(*) INTO elements
  FROM endcap ec
  WHERE ec.standard = idStandard;

  IF (elements > 0) THEN
    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', ec.id,
      'endcap', ec.name)) INTO result
    FROM endcap ec
    WHERE ec.standard = idStandard;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create function `existEndCap`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existEndCap (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM endcap e
  WHERE e.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `deleteEndCap`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteEndCap (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existEndCap(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM endcap cp
    WHERE cp.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectEndCaps`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectEndCaps (IN idStandard int UNSIGNED)
BEGIN

  SELECT
    e.id AS `id`,
    e.name AS `endCap`
  FROM endcap e
  WHERE e.standard = idStandard;

END
$$

--
-- Create procedure `insertEndCap`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertEndCap (IN idStandard int UNSIGNED, IN endCap varbinary(15))
DETERMINISTIC
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM endcap ec
  WHERE ec.name = endCap
  AND ec.name = endCap;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO endcap (standard, name)
      VALUES (idStandard, endCap);

    SELECT
      ec.id AS `key`,
      ec.name AS `endcap`
    FROM endcap ec
    WHERE ec.name = endCap
    AND ec.name = endCap;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `conditional_period`
--
CREATE TABLE IF NOT EXISTS conditional_period (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  standard int UNSIGNED NOT NULL,
  time int UNSIGNED NOT NULL DEFAULT 0,
  timeType varchar(3) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'h',
  aproxTime int UNSIGNED NOT NULL DEFAULT 0,
  aproxType varchar(3) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'min',
  minwall int UNSIGNED NOT NULL,
  maxwall int UNSIGNED NOT NULL,
  createdAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updatedtAt datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 3276,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_unicode_ci,
COMMENT = 'Conditional Period related to Standard',
ROW_FORMAT = DYNAMIC;

--
-- Create foreign key
--
ALTER TABLE conditional_period
ADD CONSTRAINT FK_conditional_period_standard_id FOREIGN KEY (standard)
REFERENCES standard (id);

DELIMITER $$

--
-- Create function `selectConditionalPeriods_has_Standard`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS selectConditionalPeriods_has_Standard (idStandard int UNSIGNED)
RETURNS json
DETERMINISTIC
COMMENT 'Selection of Conditional Periods of a Standard'
BEGIN

  DECLARE result json;
  DECLARE elements tinyint(1);

  SELECT
    COUNT(*) INTO elements
  FROM conditional_period cp
  WHERE cp.standard = idStandard;

  IF (elements > 0) THEN
    WITH periodsOrder
    AS
    (SELECT
        cp.id AS `key`,
        CONCAT(CONVERT(cp.time, char), ' ', cp.timeType, ' ± ', CONVERT(cp.aproxTime, char), ' ', cp.aproxType) AS `condPeriod`,
        cp.minwall,
        cp.maxwall
      FROM conditional_period cp
      WHERE cp.standard = idStandard)

    SELECT
      JSON_ARRAYAGG(JSON_OBJECT('key', po.`key`,
      'condPeriod', po.condPeriod,
      'minwall', po.minwall,
      'maxwall', po.maxwall)) INTO result
    FROM periodsOrder po;
  ELSE
    SELECT
      '[]' INTO result;
  END IF;

  RETURN result;
END
$$

--
-- Create procedure `selectStandardsJSON`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectStandardsJSON ()
DETERMINISTIC
BEGIN

  SELECT
    JSON_ARRAYAGG(JSON_OBJECT('key', s.id,
    'standard', s.name,
    'materials', (selectMaterials_has_Standard(s.id)),
    'enviroments', (selectEnviroments_has_Standard(s.id)),
    'endCaps', (selectEndCaps_has_Standard(s.id)),
    'conditionalPeriods', (selectConditionalPeriods_has_Standard(s.id)),
    'testTypes', (selectTest_Type(s.id)))) AS `standards`
  FROM standard s;

END
$$

--
-- Create function `existConditionalPeriod`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existConditionalPeriod (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM conditional_period cp
  WHERE cp.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `deleteConditionalPeriod`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteConditionalPeriod (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existConditionalPeriod(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM conditional_period cp
    WHERE cp.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectStandarsComplete`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectStandarsComplete ()
DETERMINISTIC
BEGIN

  SELECT
    s.id,
    s.name,
    (SELECT
        JSON_ARRAYAGG(JSON_OBJECT('id', e.id,
        'endcap', e.name))
      FROM endcap e
      WHERE e.standard = s.id) AS `endCaps`,
    (SELECT
        JSON_ARRAYAGG(JSON_OBJECT('id', e.id,
        'insertFluid', e.inside,
        'outsideFluid', e.outside))
      FROM enviroment e
      WHERE e.standard = s.id) AS `enviroment`,
    (SELECT
        JSON_ARRAYAGG(JSON_OBJECT('id', cp.id,
        'minwall', cp.minwall,
        'maxwall', cp.maxwall,
        'time', cp.time))
      FROM conditional_period cp
      WHERE cp.standard = s.id) AS conditionalPeriod,
    (SELECT
        JSON_ARRAYAGG(JSON_OBJECT('id', mhs.id,
        'idMaterial', mhs.material,
        'material', m.name,
        'description', m.description))
      FROM material_has_standard mhs
        INNER JOIN material m
          ON mhs.material = m.id
      WHERE mhs.standard = s.id) AS relatedMaterial
  FROM standard s;

END
$$

--
-- Create procedure `selectConditionalPeriods`
--
CREATE
DEFINER = 'root'@'%'
PROCEDURE IF NOT EXISTS selectConditionalPeriods (IN idStandard int UNSIGNED)
DETERMINISTIC
COMMENT 'Selection of Conditional Periods by Standard'
BEGIN

  SELECT
    cp.id AS idCondPeriod,
    cp.minwall AS minWall,
    cp.maxwall AS maxWall,
    (CONCAT(CONVERT(cp.time, char), ' ', cp.timeType, ' ± ', CONVERT(cp.aproxTime, char), ' ', cp.aproxType)) AS condPeriod
  FROM conditional_period cp
  WHERE cp.standard = idStandard
  ORDER BY cp.minwall;

END
$$

--
-- Create procedure `insertConditionalPeriod`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertConditionalPeriod (IN idStandard int UNSIGNED, IN minwall int UNSIGNED, IN maxwall int UNSIGNED, IN time int UNSIGNED, IN timeType varchar(3), IN aproxTime int UNSIGNED, IN aproxType varchar(3))
DETERMINISTIC
COMMENT 'Insertion of new Conditional Period'
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM conditional_period cp
  WHERE cp.standard = idStandard
  AND cp.minwall = minwall
  AND cp.maxwall = maxwall
  AND cp.time = time
  AND cp.timeType LIKE timeType
  AND cp.aproxTime = aproxTime
  AND cp.aproxType LIKE aproxType;

  IF elements = 0 THEN
    INSERT HIGH_PRIORITY INTO conditional_period (standard, time, timeType, aproxTime, aproxType, minwall, maxwall)
      VALUES (idStandard, time, timeType, aproxTime, aproxType, minwall, maxwall);

    SELECT
      cp.id AS `key`,
      CONCAT(CONVERT(cp.time, char), ' ', cp.timeType, ' ± ', CONVERT(cp.aproxTime, char), ' ', cp.aproxType) AS `condperiod`,
      cp.minwall AS `minwall`,
      cp.maxwall AS `maxwall`
    FROM conditional_period cp
    WHERE cp.standard = idStandard
    AND cp.minwall = minwall
    AND cp.maxwall = maxwall
    AND cp.time LIKE time;

  ELSE
    SELECT
      'Already Exist!' AS `response`;
  END IF;

END
$$

DELIMITER ;

--
-- Create table `operator`
--
CREATE TABLE IF NOT EXISTS operator (
  id int UNSIGNED NOT NULL AUTO_INCREMENT,
  dni int UNSIGNED NOT NULL,
  name varchar(50) NOT NULL,
  familyname varchar(50) NOT NULL,
  createdAt datetime(4) NOT NULL DEFAULT CURRENT_TIMESTAMP(4),
  updatedAt datetime(4) NOT NULL DEFAULT CURRENT_TIMESTAMP(4) ON UPDATE CURRENT_TIMESTAMP(4),
  PRIMARY KEY (id)
)
ENGINE = INNODB,
AVG_ROW_LENGTH = 2730,
CHARACTER SET utf8mb4,
COLLATE utf8mb4_0900_ai_ci,
COMMENT = 'Test Operator',
ROW_FORMAT = DYNAMIC;

DELIMITER $$

--
-- Create function `existOperator`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION IF NOT EXISTS existOperator (id int UNSIGNED)
RETURNS tinyint(1)
DETERMINISTIC
BEGIN

  DECLARE selected bigint(255);
  SELECT
    COUNT(*) INTO selected
  FROM operator o
  WHERE o.id = id;

  IF selected != 1 THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

END
$$

--
-- Create procedure `updateOperator`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS updateOperator (IN id int UNSIGNED, IN dni int UNSIGNED, IN name varchar(50), IN familyname varchar(50))
DETERMINISTIC
BEGIN

  DECLARE result text;

  IF (existOperator(id) = TRUE) THEN
    UPDATE LOW_PRIORITY operator o
    SET o.dni = dni,
        o.name = name,
        o.familyname = familyname
    WHERE o.id = id;

    SELECT
      'Successful Updated!' INTO result;
  ELSE
    SELECT
      'Unsuccessful Updated!' INTO result;
  END IF;

  SELECT
    result AS response;

END
$$

--
-- Create procedure `deleteOperator`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS deleteOperator (IN id int UNSIGNED)
DETERMINISTIC
BEGIN

  IF (existOperator(id) = TRUE) THEN
    DELETE LOW_PRIORITY QUICK
      FROM operator o
    WHERE o.id = id
    LIMIT 1;

    SELECT
      'Successful Deleted!' AS `response`;
  ELSE
    SELECT
      'Unsuccessful Deleted!' AS `response`;
  END IF;

END
$$

--
-- Create procedure `selectOperatorsJSON`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectOperatorsJSON ()
DETERMINISTIC
BEGIN

  SELECT
    JSON_ARRAYAGG(JSON_OBJECT('key', o.id,
    'dni', o.dni,
    'name', o.name,
    'familyName', o.familyname)) AS `operators`
  FROM operator o;

END
$$

--
-- Create procedure `selectOperators`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS selectOperators ()
DETERMINISTIC
BEGIN

  SELECT
    o.id,
    o.dni,
    o.name,
    o.familyname
  FROM operator o;

END
$$

--
-- Create procedure `insertOperator`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE IF NOT EXISTS insertOperator (IN dni int UNSIGNED, IN name varchar(20), IN familyname varchar(30))
DETERMINISTIC
BEGIN

  DECLARE selected bigint;

  SELECT
    COUNT(*) INTO selected
  FROM operator o
  WHERE o.dni = dni;

  IF (selected = 0) THEN
    INSERT INTO operator (dni, name, familyname)
      VALUES (dni, name, familyname);

    SELECT
      o.id AS `key`,
      o.dni AS `dni`,
      o.name AS `name`,
      o.familyname AS `familyName`
    FROM operator o
    WHERE o.dni = dni;

  ELSE
    SELECT
      'Already Exists!' AS `response`;
  END IF;

END
$$

DELIMITER ;

CREATE USER IF NOT EXISTS 'dataCollector'@'%' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE NEVER;
GRANT EXECUTE ON PROCEDURE data_db.countspecimens TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.insertdata TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.insertsample TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.insertspecimen TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selectsample TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selectsampleid TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selectspecimen TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectconditionalperiods TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectendcaps TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectenviroment TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectmaterials TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectoperators TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectsettingsspecification TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectspecifications TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectstandards TO 'dataCollector'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selecttesttype TO 'dataCollector'@'%';

CREATE USER IF NOT EXISTS 'databaseManager'@'%' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE NEVER;
GRANT SELECT ON TABLE static_db.material TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deleteconditionalperiod TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deleteendcap TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deleteenviroment TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deletematerial TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deleteoperator TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deleterelatedmaterial TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deletesettingsspecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deletespecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deletestandard TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.deletetesttype TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertconditionalperiod TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertendcap TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertenviroment TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertmaterial TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertoperator TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertrelatedmaterial TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertsettingsspecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertspecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.insertstandard TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.inserttesttype TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectmaterialsjson TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectoperatorsjson TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.selectstandardsjson TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.updatematerial TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.updateoperator TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.updatesettingsspecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.updatespecification TO 'databaseManager'@'%';
GRANT EXECUTE ON PROCEDURE static_db.updatestandard TO 'databaseManager'@'%';

CREATE USER IF NOT EXISTS 'mysql.infoschema'@'localhost' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE DEFAULT ACCOUNT LOCK;
GRANT SELECT, AUDIT_ABORT_EXEMPT, FIREWALL_EXEMPT, SYSTEM_USER ON *.* TO 'mysql.infoschema'@'localhost';

CREATE USER IF NOT EXISTS 'mysql.session'@'localhost' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE DEFAULT ACCOUNT LOCK;
GRANT SHUTDOWN, SUPER, AUDIT_ABORT_EXEMPT, AUTHENTICATION_POLICY_ADMIN, BACKUP_ADMIN, CLONE_ADMIN, CONNECTION_ADMIN, FIREWALL_EXEMPT, PERSIST_RO_VARIABLES_ADMIN, SESSION_VARIABLES_ADMIN, SYSTEM_USER, SYSTEM_VARIABLES_ADMIN ON *.* TO 'mysql.session'@'localhost';
GRANT SELECT ON performance_schema.* TO 'mysql.session'@'localhost';
GRANT SELECT ON TABLE mysql.user TO 'mysql.session'@'localhost';

CREATE USER IF NOT EXISTS 'mysql.sys'@'localhost' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE DEFAULT ACCOUNT LOCK;
GRANT AUDIT_ABORT_EXEMPT, FIREWALL_EXEMPT, SYSTEM_USER ON *.* TO 'mysql.sys'@'localhost';
GRANT TRIGGER ON sys.* TO 'mysql.sys'@'localhost';
GRANT SELECT ON TABLE sys.sys_config TO 'mysql.sys'@'localhost';

CREATE USER IF NOT EXISTS 'reportGenerator'@'%' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE NEVER;
GRANT EXECUTE ON *.* TO 'reportGenerator'@'%';
GRANT EXECUTE ON static_db.* TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.deletetest TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selectcomparetests TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selecttest TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selecttestdata TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.selecttests TO 'reportGenerator'@'%';
GRANT EXECUTE ON PROCEDURE data_db.updatespecimen TO 'reportGenerator'@'%';

CREATE USER IF NOT EXISTS 'root'@'%' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE DEFAULT;
GRANT USAGE ON *.* TO 'root'@'%'
WITH GRANT OPTION;
GRANT ALTER, ALTER ROUTINE, CREATE, CREATE ROLE, CREATE ROUTINE, CREATE TABLESPACE, CREATE TEMPORARY TABLES, CREATE USER, CREATE VIEW, DELETE, DROP, DROP ROLE, EVENT, EXECUTE, FILE, INDEX, INSERT, LOCK TABLES, PROCESS, REFERENCES, RELOAD, REPLICATION CLIENT, REPLICATION SLAVE, SELECT, SHOW DATABASES, SHOW VIEW, SHUTDOWN, SUPER, TRIGGER, UPDATE, ALLOW_NONEXISTENT_DEFINER, APPLICATION_PASSWORD_ADMIN, AUDIT_ABORT_EXEMPT, AUDIT_ADMIN, AUTHENTICATION_POLICY_ADMIN, BACKUP_ADMIN, BINLOG_ADMIN, BINLOG_ENCRYPTION_ADMIN, CLONE_ADMIN, CONNECTION_ADMIN, ENCRYPTION_KEY_ADMIN, FIREWALL_EXEMPT, FLUSH_OPTIMIZER_COSTS, FLUSH_STATUS, FLUSH_TABLES, FLUSH_USER_RESOURCES, GROUP_REPLICATION_ADMIN, GROUP_REPLICATION_STREAM, INNODB_REDO_LOG_ARCHIVE, INNODB_REDO_LOG_ENABLE, PASSWORDLESS_USER_ADMIN, PERSIST_RO_VARIABLES_ADMIN, REPLICATION_APPLIER, REPLICATION_SLAVE_ADMIN, RESOURCE_GROUP_ADMIN, RESOURCE_GROUP_USER, ROLE_ADMIN, SENSITIVE_VARIABLES_OBSERVER, SERVICE_CONNECTION_ADMIN, SESSION_VARIABLES_ADMIN, SET_ANY_DEFINER, SHOW_ROUTINE, SYSTEM_USER, SYSTEM_VARIABLES_ADMIN, TABLE_ENCRYPTION_ADMIN, TELEMETRY_LOG_ADMIN, TRANSACTION_GTID_TAG, XA_RECOVER_ADMIN ON *.* TO 'root'@'%';

CREATE USER IF NOT EXISTS 'root'@'localhost' IDENTIFIED WITH caching_sha2_password PASSWORD EXPIRE DEFAULT;
GRANT USAGE ON *.* TO 'root'@'localhost'
WITH GRANT OPTION;
GRANT ALLOW_NONEXISTENT_DEFINER, ALTER, ALTER ROUTINE, APPLICATION_PASSWORD_ADMIN, AUDIT_ABORT_EXEMPT, AUDIT_ADMIN, AUTHENTICATION_POLICY_ADMIN, BACKUP_ADMIN, BINLOG_ADMIN, BINLOG_ENCRYPTION_ADMIN, CLONE_ADMIN, CONNECTION_ADMIN, CREATE, CREATE ROLE, CREATE ROUTINE, CREATE TABLESPACE, CREATE TEMPORARY TABLES, CREATE USER, CREATE VIEW, DELETE, DROP, DROP ROLE, ENCRYPTION_KEY_ADMIN, EVENT, EXECUTE, FILE, FIREWALL_EXEMPT, FLUSH_OPTIMIZER_COSTS, FLUSH_STATUS, FLUSH_TABLES, FLUSH_USER_RESOURCES, GROUP_REPLICATION_ADMIN, GROUP_REPLICATION_STREAM, INDEX, INNODB_REDO_LOG_ARCHIVE, INNODB_REDO_LOG_ENABLE, INSERT, LOCK TABLES, PASSWORDLESS_USER_ADMIN, PERSIST_RO_VARIABLES_ADMIN, PROCESS, REFERENCES, RELOAD, REPLICATION CLIENT, REPLICATION SLAVE, REPLICATION_APPLIER, REPLICATION_SLAVE_ADMIN, RESOURCE_GROUP_ADMIN, RESOURCE_GROUP_USER, ROLE_ADMIN, SELECT, SENSITIVE_VARIABLES_OBSERVER, SERVICE_CONNECTION_ADMIN, SESSION_VARIABLES_ADMIN, SET_ANY_DEFINER, SHOW DATABASES, SHOW VIEW, SHOW_ROUTINE, SHUTDOWN, SUPER, SYSTEM_USER, SYSTEM_VARIABLES_ADMIN, TABLE_ENCRYPTION_ADMIN, TELEMETRY_LOG_ADMIN, TRANSACTION_GTID_TAG, TRIGGER, UPDATE, XA_RECOVER_ADMIN ON *.* TO 'root'@'localhost';

GRANT PROXY ON ''@'' TO 'root'@'%' WITH GRANT OPTION;

GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION;

-- Table static_db.material does not contain any data (it is empty)

-- Table static_db.specification does not contain any data (it is empty)

-- Table static_db.standard does not contain any data (it is empty)

-- Table static_db.test_type does not contain any data (it is empty)

-- Table static_db.settings_specification does not contain any data (it is empty)

-- Table static_db.operator does not contain any data (it is empty)

-- Table static_db.material_has_standard does not contain any data (it is empty)

-- Table static_db.enviroment does not contain any data (it is empty)

-- Table static_db.endcap does not contain any data (it is empty)

-- Table static_db.conditional_period does not contain any data (it is empty)

--
-- Set default database
--
USE static_db;

DELIMITER $$

--
-- Create trigger `deleteStandardChilds`
--
CREATE
DEFINER = 'root'@'localhost'
TRIGGER IF NOT EXISTS deleteStandardChilds
BEFORE DELETE
ON standard
FOR EACH ROW
BEGIN

  DECLARE elements int UNSIGNED;

  SELECT
    COUNT(*) INTO elements
  FROM endcap e
  WHERE e.standard = OLD.id;

  IF elements > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM endcap e
    WHERE e.standard = OLD.id;
  END IF;

  SELECT
    COUNT(*) INTO elements
  FROM conditional_period cp
  WHERE cp.standard = OLD.id;

  IF elements > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM conditional_period cp
    WHERE cp.standard = OLD.id;
  END IF;

  SELECT
    COUNT(*) INTO elements
  FROM enviroment e
  WHERE e.standard = OLD.id;

  IF elements > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM enviroment e
    WHERE e.standard = OLD.id;
  END IF;

  SELECT
    COUNT(*) INTO elements
  FROM test_type tt
  WHERE tt.standard = OLD.id;

  IF elements > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM test_type tt
    WHERE tt.standard = OLD.id;
  END IF;

  SELECT
    COUNT(*) INTO elements
  FROM material_has_standard mhs
  WHERE mhs.standard = OLD.id;

  IF elements > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM material_has_standard mhs
    WHERE mhs.standard = OLD.id;
  END IF;

END
$$

--
-- Create trigger `deleteMaterialChilds`
--
CREATE
DEFINER = 'root'@'localhost'
TRIGGER IF NOT EXISTS deleteMaterialChilds
BEFORE DELETE
ON material
FOR EACH ROW
BEGIN

  DECLARE childsCount int UNSIGNED;

  SELECT
    COUNT(*) INTO childsCount
  FROM specification s
  WHERE s.material = OLD.id;

  IF childsCount > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM specification s
    WHERE s.material = OLD.id;

  END IF;

  SELECT
    COUNT(*) INTO childsCount
  FROM material_has_standard mhs
  WHERE mhs.material = OLD.id;

  IF childsCount > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM material_has_standard mhs
    WHERE mhs.material = OLD.id;

  END IF;

END
$$

--
-- Create trigger `deleteConfigurationsChilds`
--
CREATE
DEFINER = 'root'@'localhost'
TRIGGER IF NOT EXISTS deleteConfigurationsChilds
BEFORE DELETE
ON specification
FOR EACH ROW
BEGIN

  DECLARE childsCount int UNSIGNED;

  SELECT
    COUNT(*) INTO childsCount
  FROM settings_specification sc
  WHERE sc.specification = OLD.id;

  IF childsCount > 0 THEN
    DELETE LOW_PRIORITY QUICK
      FROM settings_specification sc
    WHERE sc.specification = OLD.id;

  END IF;

END
$$

DELIMITER ;

--
-- Restore previous SQL mode
--
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

--
-- Enable foreign keys
--
/*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */;